{
  "version": 3,
  "sources": ["../strip-markdown/index.js", "dep:strip-markdown"],
  "sourcesContent": ["/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Root} Root\n * @typedef {Root|Content} Node\n * @typedef {Node['type']} Type\n *\n * @callback Handler\n * @param {any} node\n * @returns {Node|Node[]} node\n *\n * @typedef {Partial<Record<Type, Handler>>} Handlers\n *\n * @typedef Options\n *   Configuration.\n * @property {Array.<Type>|undefined} [keep]\n *   List of node types to leave unchanged.\n * @property {Array.<Type|[Type, Handler]>|undefined} [remove]\n *   List of additional node types to remove or replace.\n */\n\n/**\n * Expose modifiers for available node types.\n * Node types not listed here are not changed (but their children are).\n *\n * @type {Handlers}\n */\nconst defaults = {\n  heading: paragraph,\n  text,\n  inlineCode: text,\n  image,\n  imageReference: image,\n  break: lineBreak,\n\n  blockquote: children,\n  list: children,\n  listItem: children,\n  strong: children,\n  emphasis: children,\n  delete: children,\n  link: children,\n  linkReference: children,\n\n  code: empty,\n  thematicBreak: empty,\n  html: empty,\n  table: empty,\n  tableCell: empty,\n  definition: empty,\n  yaml: empty,\n\n  // @ts-expect-error: custom frontmatter node.\n  toml: empty,\n\n  footnoteReference: empty,\n  footnoteDefinition: empty\n}\n\nconst own = {}.hasOwnProperty\n\n/**\n * Plugin to remove markdown formatting.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root>}\n * @returns {import('unified').Transformer<Root>}\n */\nexport default function stripMarkdown(options = {}) {\n  const handlers = Object.assign({}, defaults)\n  const remove = options.remove || []\n  const keep = options.keep || []\n\n  let index = -1\n\n  while (++index < remove.length) {\n    const value = remove[index]\n\n    if (Array.isArray(value)) {\n      handlers[value[0]] = value[1]\n    } else {\n      handlers[value] = empty\n    }\n  }\n\n  /** @type {Handlers} */\n  let map = {}\n\n  if (keep.length === 0) {\n    map = handlers\n  } else {\n    /** @type {Type} */\n    let key\n\n    for (key in handlers) {\n      if (!keep.includes(key)) {\n        map[key] = handlers[key]\n      }\n    }\n\n    index = -1\n\n    // Warn if unknown keys are turned off.\n    while (++index < keep.length) {\n      key = keep[index]\n\n      if (!own.call(handlers, key)) {\n        throw new Error(\n          'Invalid `keep` option: No modifier is defined for node type `' +\n            key +\n            '`'\n        )\n      }\n    }\n  }\n\n  // @ts-expect-error: assume content model (for root) matches.\n  return one\n\n  /**\n   * @param {Node} node\n   * @returns {Node|Node[]}\n   */\n  function one(node) {\n    /** @type {Type} */\n    const type = node.type\n    /** @type {Node|Node[]} */\n    let result = node\n\n    if (type in map) {\n      const handler = map[type]\n      if (handler) result = handler(result)\n    }\n\n    result = Array.isArray(result) ? all(result) : result\n\n    if ('children' in result) {\n      // @ts-expect-error: assume content models match.\n      result.children = all(result.children)\n    }\n\n    return result\n  }\n\n  /**\n   * @param {Node[]} nodes\n   * @returns {Node[]}\n   */\n  function all(nodes) {\n    let index = -1\n    /** @type {Node[]} */\n    const result = []\n\n    while (++index < nodes.length) {\n      const value = one(nodes[index])\n\n      if (Array.isArray(value)) {\n        result.push(...value.flatMap((d) => one(d)))\n      } else {\n        result.push(value)\n      }\n    }\n\n    return clean(result)\n  }\n}\n\n/**\n * Clean nodes: merges literals.\n *\n * @param {Node[]} values\n * @returns {Node[]}\n */\nfunction clean(values) {\n  let index = -1\n  /** @type {Node[]} */\n  const result = []\n  /** @type {Node|undefined} */\n  let previous\n\n  while (++index < values.length) {\n    const value = values[index]\n\n    if (previous && value.type === previous.type && 'value' in value) {\n      // @ts-expect-error: we just checked that they\u2019re the same node.\n      previous.value += value.value\n    } else {\n      result.push(value)\n      previous = value\n    }\n  }\n\n  return result\n}\n\n/**\n * @type {Handler}\n * @param {import('mdast').Image|import('mdast').ImageReference} node\n */\nfunction image(node) {\n  const title = 'title' in node ? node.title : ''\n  return {type: 'text', value: node.alt || title || ''}\n}\n\n/**\n * @type {Handler}\n * @param {import('mdast').Text} node\n */\nfunction text(node) {\n  return {type: 'text', value: node.value}\n}\n\n/**\n * @type {Handler}\n * @param {import('mdast').Paragraph} node\n */\nfunction paragraph(node) {\n  return {type: 'paragraph', children: node.children}\n}\n\n/**\n * @type {Handler}\n * @param {Extract<Node, import('unist').Parent>} node\n */\nfunction children(node) {\n  return node.children || []\n}\n\n/**\n * @type {Handler}\n */\nfunction lineBreak() {\n  return {type: 'text', value: '\\n'}\n}\n\n/**\n * @type {Handler}\n */\nfunction empty() {\n  return {type: 'text', value: ''}\n}\n", "import d from \"./node_modules/strip-markdown/index.js\";export default d;"],
  "mappings": "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",
  "names": []
}
